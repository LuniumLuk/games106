#version 450

#extension GL_EXT_shader_atomic_float : require

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D u_input;
layout (binding = 1, r8ui) uniform uimage2D u_output;

#define PALETTE_SIZE 6
#define PALETTE_1_INVOCATION_PER_PIXEL      5
#define PALETTE_1_INVOCATION_PER_2X1_PIXELS 6
#define PALETTE_1_INVOCATION_PER_1X2_PIXELS 7
#define PALETTE_1_INVOCATION_PER_2X2_PIXELS 8
#define PALETTE_1_INVOCATION_PER_4X2_PIXELS 9
#define PALETTE_1_INVOCATION_PER_2X4_PIXELS 10

#define PALETTE_1_INVOCATION_PER_4X4_PIXELS 11

float g_distMap[PALETTE_SIZE] = { 8.0, 12.0, 16.0, 18.0, 20.0, 24.0 };
uint g_shadingRate[PALETTE_SIZE] = {
	PALETTE_1_INVOCATION_PER_PIXEL,
	PALETTE_1_INVOCATION_PER_2X1_PIXELS,
	PALETTE_1_INVOCATION_PER_1X2_PIXELS,
	PALETTE_1_INVOCATION_PER_2X2_PIXELS,
	PALETTE_1_INVOCATION_PER_4X2_PIXELS,
	PALETTE_1_INVOCATION_PER_2X4_PIXELS,
};

float luminance(vec3 color) {
	return 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
}

shared float sX;
shared float sY;
shared float sI;

void main() {
	const ivec2 inputImageSize = imageSize(u_input);
	const ivec2 outputImageSize = imageSize(u_output);
	const ivec2 texelSize = inputImageSize / outputImageSize;
	const ivec2 p = ivec2(gl_WorkGroupID.xy);
	const ivec2 texelCoord = ivec2(gl_WorkGroupID.xy) * texelSize;

	// initialize shared memory
	if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
		sX = 0.0;
		sY = 0.0;
		sI = 0.0;
	}
	memoryBarrierShared();

	// compute derivatives and accumulate
	if (gl_LocalInvocationID.x < texelSize.x && gl_LocalInvocationID.y < texelSize.y) {
		float m = luminance(imageLoad(u_input, texelCoord + ivec2(gl_LocalInvocationID.x, gl_LocalInvocationID.y)).rgb);
		if (gl_LocalInvocationID.x > 0) {
			float n = luminance(imageLoad(u_input, texelCoord + ivec2(gl_LocalInvocationID.x - 1, gl_LocalInvocationID.y)).rgb);
			float dx = (m - n) * 0.5;
			atomicAdd(sX, dx * dx);
		}
		if (gl_LocalInvocationID.y > 0) {
			float n = luminance(imageLoad(u_input, texelCoord + ivec2(gl_LocalInvocationID.x, gl_LocalInvocationID.y - 1)).rgb);
			float dy = (m - n) * 0.5;
			atomicAdd(sY, dy * dy);
		}
		atomicAdd(sI, m);
	}
	memoryBarrierShared();

	// result will be gathered and output by the main thread
	if (gl_LocalInvocationID.x == 0 && gl_LocalInvocationID.y == 0) {
		const float E_HX = sqrt(sX / float(texelSize.x - 1));
		const float E_HY = sqrt(sY / float(texelSize.y - 1));
		const float I_avg = sI / float(texelSize.x * texelSize.y);
		const float t = 0.15;
		const float l = 0.0;
		const float k = 2.13;
		const float tau = t * (I_avg + l);

		uint shadingRate = PALETTE_1_INVOCATION_PER_4X4_PIXELS;
		uint rX = 2;
		uint rY = 2;
		if (E_HX >= tau) {
			rX = 1;
		}
		else if (k * E_HX < tau) {
			rX = 4;
		}

		if (E_HY >= tau) {
			rY = 1;
		}
		else if (k * E_HY < tau) {
			rY = 4;
		}

		if (rX == 1 && rY == 1) {
			shadingRate = PALETTE_1_INVOCATION_PER_PIXEL;
		}
		else if (rX == 1 && rY == 2) {
			shadingRate = PALETTE_1_INVOCATION_PER_1X2_PIXELS;
		}
		else if (rX == 2 && rY == 1) {
			shadingRate = PALETTE_1_INVOCATION_PER_2X1_PIXELS;
		}
		else if (rX == 2 && rY == 2) {
			shadingRate = PALETTE_1_INVOCATION_PER_2X2_PIXELS;
		}
		else if (rX == 4 && rY == 2) {
			shadingRate = PALETTE_1_INVOCATION_PER_4X2_PIXELS;
		}
		else if (rX == 2 && rY == 4) {
			shadingRate = PALETTE_1_INVOCATION_PER_2X4_PIXELS;
		}

		uvec4 ret = uvec4(shadingRate, 0, 0, 0);
		imageStore(u_output, p, ret);
	}
}
